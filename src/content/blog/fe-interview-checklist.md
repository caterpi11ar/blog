---
title: 前端面试知识点检查清单
author: caterpillar
pubDatetime: 2025-08-10T06:00:00
featured: false
draft: false
tags:
  - 面试
  - 检查清单
  - JavaScript
  - React
  - 算法
description: 前端面试必备知识点检查清单，覆盖 JavaScript、React、浏览器、网络、算法、工程化等核心领域。
---

## 使用说明

本检查清单旨在帮你系统性地自检前端面试核心知识点掌握情况。建议：

- **每周自检**：选择 1-2 个模块进行深度检查
- **口述练习**：尝试不看资料口述每个知识点
- **时间控制**：每个问题控制在 3-5 分钟内回答完成
- **查漏补缺**：标记薄弱环节，制定针对性学习计划

评分标准：
- ✅ **掌握**：能够清晰解释原理，举出实际案例，分析优缺点
- ⚠️ **部分掌握**：理解基本概念，但细节不够清楚或缺乏实践经验
- ❌ **需要学习**：概念模糊或完全不了解

## JavaScript 核心

### 数据类型与类型检测
- [ ] 7 种基本数据类型 + Object 类型的特点
- [ ] `typeof`、`instanceof`、`Object.prototype.toString` 的区别和使用场景
- [ ] 类型转换规则：隐式转换、`==` vs `===`、`+` 操作符的类型转换
- [ ] 判断数组的多种方法及其原理
- [ ] `null` 和 `undefined` 的区别及使用场景

### 作用域与闭包
- [ ] 词法作用域 vs 动态作用域的概念
- [ ] 执行上下文、作用域链的工作机制
- [ ] 变量提升（hoisting）的原理和注意事项
- [ ] 暂时性死区（TDZ）及其作用
- [ ] 闭包的形成条件、应用场景和潜在问题
- [ ] 立即执行函数（IIFE）的作用和使用场景

### this 绑定机制
- [ ] this 的四种绑定规则：默认、隐式、显式、new 绑定
- [ ] 箭头函数的 this 绑定特点
- [ ] `call`、`apply`、`bind` 的区别和实现原理
- [ ] 严格模式对 this 的影响
- [ ] 在不同场景下 this 的指向判断

### 原型与继承
- [ ] `__proto__` 与 `prototype` 的区别和关系
- [ ] 原型链的查找机制和终点
- [ ] `instanceof` 操作符的工作原理
- [ ] 几种继承模式：原型继承、构造函数继承、组合继承、寄生组合继承
- [ ] ES6 class 的本质及与构造函数的区别
- [ ] `Object.create`、`Object.setPrototypeOf` 的使用

### 异步编程
- [ ] JavaScript 运行时模型：Call Stack、Web APIs、Callback Queue、Event Loop
- [ ] 宏任务（macrotask）与微任务（microtask）的执行顺序
- [ ] Promise 的状态机制和链式调用原理
- [ ] `async/await` 的语法糖本质和错误处理
- [ ] 并发控制：`Promise.all`、`Promise.race`、`Promise.allSettled`、`Promise.any`
- [ ] Node.js 事件循环与浏览器的差异

### 函数式编程
- [ ] 高阶函数的概念和应用
- [ ] 柯里化（Currying）和偏应用（Partial Application）
- [ ] 函数组合（Function Composition）
- [ ] 纯函数的概念和优势
- [ ] 防抖（debounce）和节流（throttle）的实现和应用场景

## TypeScript 类型系统

### 基础类型系统
- [ ] 基础类型：`string`、`number`、`boolean`、`array`、`tuple`、`enum`、`any`、`unknown`、`void`、`never`
- [ ] 联合类型和交叉类型的使用场景
- [ ] 类型断言的使用和风险
- [ ] 字面量类型和类型收窄
- [ ] 可选属性和只读属性

### 高级类型特性
- [ ] 泛型的概念、约束和默认类型参数
- [ ] 条件类型的语法和应用场景
- [ ] 映射类型的实现原理
- [ ] 模板字面量类型的使用
- [ ] `infer` 关键字的作用和使用方法

### 工具类型和类型操作
- [ ] 内置工具类型：`Partial`、`Required`、`Pick`、`Omit`、`Exclude`、`Extract`、`NonNullable`、`Record`
- [ ] 自定义工具类型的实现
- [ ] 分布式条件类型的特性
- [ ] 协变和逆变的概念
- [ ] 类型兼容性和结构化类型系统

## React 核心原理

### 组件和生命周期
- [ ] 函数组件 vs 类组件的区别和选择
- [ ] React 生命周期方法及其使用场景
- [ ] `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 的常见用法
- [ ] `getDerivedStateFromProps` 和 `getSnapshotBeforeUpdate` 的使用场景
- [ ] 错误边界（Error Boundaries）的实现和应用

### Hooks 原理和最佳实践
- [ ] Hooks 的设计动机和解决的问题
- [ ] `useState` 的工作原理和批量更新机制
- [ ] `useEffect` 的执行时机和依赖数组规则
- [ ] `useLayoutEffect` 与 `useEffect` 的区别
- [ ] `useMemo` 和 `useCallback` 的使用场景和注意事项
- [ ] `useRef` 的多种用法：DOM 引用、可变值存储
- [ ] 自定义 Hooks 的设计原则和最佳实践
- [ ] Hooks 规则的原因和底层实现

### 虚拟 DOM 和 Diff 算法
- [ ] 虚拟 DOM 的概念和优势
- [ ] React Diff 算法的三个假设和优化策略
- [ ] key 的作用机制和最佳实践
- [ ] 单节点 Diff 和多节点 Diff 的处理逻辑
- [ ] React 18 中 Diff 算法的改进

### Fiber 架构和调度
- [ ] Fiber 的设计目标和解决的问题
- [ ] Fiber 数据结构：type、key、props、stateNode、alternate
- [ ] 双缓存机制：current 树和 workInProgress 树
- [ ] 时间片调度和可中断渲染
- [ ] 优先级调度：lanes 模型和优先级更新
- [ ] 并发特性：Concurrent Mode、Suspense、startTransition

### 状态管理和数据流
- [ ] React 单向数据流的特点
- [ ] 状态提升和状态下沉的场景
- [ ] Context API 的使用和性能考虑
- [ ] Redux 的设计原则和中间件机制
- [ ] React Query/SWR 的缓存策略和数据同步

## 浏览器原理

### 渲染流水线
- [ ] 浏览器渲染过程：解析 → 样式 → 布局 → 绘制 → 合成
- [ ] HTML 解析和 DOM 构建过程
- [ ] CSS 解析和 CSSOM 构建
- [ ] 渲染树（Render Tree）的构建过程
- [ ] 布局（Layout/Reflow）的触发条件和优化
- [ ] 绘制（Paint）和复合（Composite）的层级关系

### 性能优化
- [ ] 回流（Reflow）和重绘（Repaint）的区别和优化策略
- [ ] CSS 包含块和层叠上下文的概念
- [ ] 硬件加速和合成层的触发条件
- [ ] `will-change` 属性的使用和注意事项
- [ ] 关键渲染路径的优化策略
- [ ] Web Vitals 指标：LCP、FID、CLS、FCP、TTFB

### 缓存机制
- [ ] 强缓存：`Cache-Control` 和 `Expires` 的区别
- [ ] 协商缓存：`ETag`/`If-None-Match` 和 `Last-Modified`/`If-Modified-Since`
- [ ] 缓存策略的选择和最佳实践
- [ ] Service Worker 的缓存控制
- [ ] HTTP/2 的缓存优化

### 跨域和安全
- [ ] 同源策略的定义和作用
- [ ] CORS 的工作机制：简单请求和预检请求
- [ ] 跨域解决方案：JSONP、代理、PostMessage
- [ ] XSS 攻击的类型和防护措施
- [ ] CSRF 攻击的原理和防护策略
- [ ] CSP（Content Security Policy）的配置和作用

## 计算机网络

### HTTP 协议
- [ ] HTTP/1.1 的特性：持久连接、管道化、缓存控制
- [ ] HTTP/2 的改进：二进制帧、多路复用、服务端推送、头部压缩
- [ ] HTTP/3 和 QUIC 的特点：UDP 传输、连接迁移、0-RTT
- [ ] HTTPS 和 TLS 握手过程
- [ ] HTTP 状态码的分类和常见状态码含义

### TCP/IP 协议栈
- [ ] OSI 七层模型和 TCP/IP 四层模型
- [ ] TCP 三次握手和四次挥手的过程
- [ ] TCP 的可靠性保证：确认机制、重传机制、流量控制、拥塞控制
- [ ] UDP 的特点和适用场景
- [ ] DNS 解析过程和优化策略

### 网络优化
- [ ] CDN 的工作原理和优势
- [ ] DNS 预解析和域名分片
- [ ] 连接复用和 Keep-Alive
- [ ] 首包时间（TTFB）的优化
- [ ] 资源压缩：Gzip、Brotli
- [ ] 图片优化：WebP、响应式图片、懒加载

## 算法与数据结构

### 时间复杂度和空间复杂度
- [ ] Big O 表示法的含义和计算方法
- [ ] 常见算法的时间复杂度：O(1)、O(log n)、O(n)、O(n log n)、O(n²)
- [ ] 最好、最坏、平均时间复杂度的区别
- [ ] 空间复杂度的计算和优化策略

### 数组和字符串
- [ ] 双指针技巧：对撞指针、快慢指针
- [ ] 滑动窗口模式的应用场景
- [ ] 前缀和和差分数组的使用
- [ ] 字符串匹配算法：KMP、Rabin-Karp
- [ ] 排序算法：冒泡、选择、插入、快排、归并、堆排序

### 链表和树
- [ ] 单链表、双链表的操作：插入、删除、反转
- [ ] 链表环的检测和入环点查找
- [ ] 二叉树的遍历：前序、中序、后序、层序
- [ ] 二叉搜索树的性质和操作
- [ ] 平衡二叉树：AVL 树、红黑树的特点
- [ ] 树的直径、深度、路径相关问题

### 高级算法
- [ ] 回溯算法的模板和剪枝策略
- [ ] 动态规划的状态定义和转移方程
- [ ] 贪心算法的适用条件和证明方法
- [ ] 二分查找的变形：查找边界、旋转数组
- [ ] 图算法：DFS、BFS、最短路径、最小生成树

## 工程化体系

### 构建工具
- [ ] Webpack 的核心概念：entry、output、loader、plugin
- [ ] 模块化规范：CommonJS、ES Module、AMD、UMD
- [ ] Tree Shaking 的原理和限制
- [ ] 代码分割的策略：入口分割、动态导入、SplitChunks
- [ ] SourceMap 的类型和选择
- [ ] Vite 的优势和与 Webpack 的区别
- [ ] Rollup 的特点和适用场景

### 质量保障
- [ ] ESLint 的配置和自定义规则
- [ ] Prettier 的代码格式化原理
- [ ] TypeScript 的编译配置和严格模式
- [ ] 测试分层：单元测试、集成测试、E2E 测试
- [ ] Jest/Vitest 的配置和使用
- [ ] React Testing Library 的测试理念
- [ ] Playwright/Cypress 的 E2E 测试策略

### 部署和监控
- [ ] CI/CD 流水线的设计和实践
- [ ] 容器化部署：Docker、Kubernetes
- [ ] 灰度发布和蓝绿部署的策略
- [ ] 前端监控的实现：错误监控、性能监控、用户行为分析
- [ ] 日志收集和分析
- [ ] 告警机制和故障排查

### 微前端和架构
- [ ] 微前端的概念和解决的问题
- [ ] Single-SPA、qiankun 的实现原理
- [ ] Module Federation 的使用和优势
- [ ] Monorepo 的管理策略：Lerna、Nx、Rush
- [ ] 组件库的设计和发布
- [ ] BFF（Backend for Frontend）模式

## 系统设计

### 设计思路
- [ ] 系统设计的基本步骤：需求分析、架构设计、详细设计、权衡分析
- [ ] 可扩展性、可用性、一致性的权衡
- [ ] 负载均衡和水平扩展策略
- [ ] 缓存策略的设计和一致性保证
- [ ] 数据库的选择和分库分表

### 前端系统设计
- [ ] 大型 SPA 应用的架构设计
- [ ] 组件库和设计系统的架构
- [ ] 状态管理的架构选择
- [ ] 路由设计和权限控制
- [ ] 性能优化的整体策略
- [ ] 可观测性的设计：监控、日志、链路追踪

### 具体场景
- [ ] 实时聊天系统的设计：WebSocket、消息队列、离线消息
- [ ] 大型列表/Feed 流的优化：虚拟滚动、分页、缓存
- [ ] 文件上传系统：分片上传、断点续传、进度显示
- [ ] 搜索系统：自动完成、搜索建议、结果排序
- [ ] 可视化大屏：数据处理、实时更新、性能优化

## 面试软技能

### 技术沟通
- [ ] 技术方案的表达：背景、方案、权衡、结果
- [ ] 复杂概念的简化解释
- [ ] 技术决策的理由和考量
- [ ] 开放性问题的思考框架

### 项目经验
- [ ] STAR 方法：Situation、Task、Action、Result
- [ ] 项目难点的识别和解决过程
- [ ] 技术选型的依据和权衡
- [ ] 团队协作和冲突处理
- [ ] 持续改进和学习总结

### 问题解决
- [ ] 调试技巧和工具使用
- [ ] 性能问题的定位和优化
- [ ] 线上故障的排查和处理
- [ ] 代码质量的保证和改进
- [ ] 技术债务的识别和清理

## 自检使用指南

### 每日检查（10-15分钟）
选择 3-5 个知识点进行快速自检：
- 能否在 2 分钟内清楚解释概念
- 能否举出 1-2 个实际应用场景
- 能否识别常见的误区或陷阱

### 每周深度检查（1-2小时）
选择 1-2 个模块进行深度检查：
- 画图解释复杂概念的工作原理
- 手写关键算法或代码实现
- 分析不同方案的优缺点和适用场景

### 模拟面试检查
- 随机选择知识点进行 5-10 分钟的详细讲解
- 模拟面试官的追问和深入提问
- 录制视频回放，分析表达的清晰度和逻辑性

### 查漏补缺计划
- 标记薄弱环节，制定专项学习计划
- 寻找相关资料和实践项目
- 定期重新检查直至完全掌握

---

> 知识点的掌握不在于能背诵概念，而在于能理解原理、分析场景、解决问题。通过持续的自检和实践，建立扎实的技术基础和解决问题的能力。
